{"ast":null,"code":"var _jsxFileName = \"/Users/anatolisaukhin/hw-02/src/s2-homeworks/hw04/common/c1-SuperInputText/SuperInputText.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\nimport s from \"./SuperInputText.module.css\";\n\n// тип пропсов обычного инпута\n\n// здесь мы говорим что у нашего инпута будут такие же пропсы как у обычного инпута, кроме type\n// (чтоб не писать value: string, onChange: ...; они уже все описаны в DefaultInputPropsType)\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SuperInputText = ({\n  onChange,\n  onChangeText,\n  onKeyPress,\n  onEnter,\n  error,\n  className,\n  spanClassName,\n  id,\n  ...restProps // все остальные пропсы попадут в объект restProps\n}) => {\n  _s();\n  // console.log(error,\"error!!!!!!\")\n\n  // console.log(value,\"defaultText value\")\n\n  //   useEffect(()=>{\n  //     // const res = restoreState<string>(\"hw6-editable-span-value\", \"hello\");\n  //     onChangeText?.(\"hello\");\n\n  // },[ ])\n  const [localState, setLocalState] = useState(restProps.value);\n  const onChangeCallback = e => {\n    onChange === null || onChange === void 0 ? void 0 : onChange(e); // если есть пропс onChange, то передать ему е (поскольку onChange не обязателен)\n\n    onChangeText === null || onChangeText === void 0 ? void 0 : onChangeText(e.currentTarget.value);\n    // onChangeText?.(\"hello\");\n  };\n  const onKeyPressCallback = e => {\n    onKeyPress === null || onKeyPress === void 0 ? void 0 : onKeyPress(e);\n    onEnter &&\n    // если есть пропс onEnter\n    e.key === \"Enter\" &&\n    // и если нажата кнопка Enter\n    onEnter(); // то вызвать его\n  };\n  const finalSpanClassName = s.error + (spanClassName ? \" \" + spanClassName : \"\");\n  const finalInputClassName = s.input + (error ? \" \" + s.errorInput : \" \" + s.superInput) + (className ? \" \" + className : \"\"); // задача на смешивание классов\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: s.inputWrapper,\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      id: id ? id + \"-span\" : undefined,\n      className: finalSpanClassName,\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 76,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      id: id,\n      type: \"text\",\n      onChange: onChangeCallback,\n      onKeyPress: onKeyPressCallback,\n      className: finalInputClassName,\n      value: localState,\n      ...restProps\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 75,\n    columnNumber: 5\n  }, this);\n};\n_s(SuperInputText, \"S7O9KntJDg3E7/uqz6x6e83qMS4=\");\n_c = SuperInputText;\nexport default SuperInputText;\nvar _c;\n$RefreshReg$(_c, \"SuperInputText\");","map":{"version":3,"names":["React","useState","s","jsxDEV","_jsxDEV","SuperInputText","onChange","onChangeText","onKeyPress","onEnter","error","className","spanClassName","id","restProps","_s","localState","setLocalState","value","onChangeCallback","e","currentTarget","onKeyPressCallback","key","finalSpanClassName","finalInputClassName","input","errorInput","superInput","inputWrapper","children","undefined","fileName","_jsxFileName","lineNumber","columnNumber","type","_c","$RefreshReg$"],"sources":["/Users/anatolisaukhin/hw-02/src/s2-homeworks/hw04/common/c1-SuperInputText/SuperInputText.tsx"],"sourcesContent":["import React, {\n  ChangeEvent,\n  DetailedHTMLProps,\n  InputHTMLAttributes,\n  KeyboardEvent,\n  ReactNode,\n  useEffect,\n  useState,\n} from \"react\";\nimport s from \"./SuperInputText.module.css\";\nimport { restoreState } from \"../../../hw06/localStorage/localStorage\";\n\n// тип пропсов обычного инпута\ntype DefaultInputPropsType = DetailedHTMLProps<\n  InputHTMLAttributes<HTMLInputElement>,\n  HTMLInputElement\n>;\n\n// здесь мы говорим что у нашего инпута будут такие же пропсы как у обычного инпута, кроме type\n// (чтоб не писать value: string, onChange: ...; они уже все описаны в DefaultInputPropsType)\ntype SuperInputTextPropsType = Omit<DefaultInputPropsType, \"type\"> & {\n  // и + ещё пропсы которых нет в стандартном инпуте\n  onChangeText?: (value: string) => void;\n  // onEnter?: () => void;\n  onEnter?: () => void;\n  error?: ReactNode;\n  spanClassName?: string;\n};\n\nconst SuperInputText: React.FC<SuperInputTextPropsType> = ({\n  onChange,\n  onChangeText,\n  onKeyPress,\n  onEnter,\n  error,\n  className,\n  spanClassName,\n  id,\n  ...restProps // все остальные пропсы попадут в объект restProps\n}) => {\n  // console.log(error,\"error!!!!!!\")\n\n  // console.log(value,\"defaultText value\")\n\n//   useEffect(()=>{\n//     // const res = restoreState<string>(\"hw6-editable-span-value\", \"hello\");\n//     onChangeText?.(\"hello\");\n\n// },[ ])\nconst [localState, setLocalState] = useState(restProps.value)\n\n  const onChangeCallback = (e: ChangeEvent<HTMLInputElement>) => {\n    onChange?.(e); // если есть пропс onChange, то передать ему е (поскольку onChange не обязателен)\n\n    onChangeText?.(e.currentTarget.value);\n    // onChangeText?.(\"hello\");\n  };\n  const onKeyPressCallback = (e: KeyboardEvent<HTMLInputElement>) => {\n    onKeyPress?.(e);\n\n    onEnter && // если есть пропс onEnter\n      e.key === \"Enter\" && // и если нажата кнопка Enter\n      onEnter(); // то вызвать его\n  };\n\n  const finalSpanClassName =\n    s.error + (spanClassName ? \" \" + spanClassName : \"\");\n\n  const finalInputClassName =\n    s.input +\n    (error ? \" \" + s.errorInput : \" \" + s.superInput) +\n    (className ? \" \" + className : \"\"); // задача на смешивание классов\n\n  return (\n    <div className={s.inputWrapper}>\n      <span id={id ? id + \"-span\" : undefined} className={finalSpanClassName}>\n        {error}\n      </span>\n\n      <input\n        id={id}\n        type={\"text\"}\n        onChange={onChangeCallback}\n        onKeyPress={onKeyPressCallback}\n        className={finalInputClassName}\n        value={localState}\n        {...restProps} // отдаём инпуту остальные пропсы если они есть (value например там внутри)\n      />\n    </div>\n  );\n};\n\nexport default SuperInputText;\n"],"mappings":";;AAAA,OAAOA,KAAK,IAOVC,QAAQ,QACH,OAAO;AACd,OAAOC,CAAC,MAAM,6BAA6B;;AAG3C;;AAMA;AACA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAUA,MAAMC,cAAiD,GAAGA,CAAC;EACzDC,QAAQ;EACRC,YAAY;EACZC,UAAU;EACVC,OAAO;EACPC,KAAK;EACLC,SAAS;EACTC,aAAa;EACbC,EAAE;EACF,GAAGC,SAAS,CAAC;AACf,CAAC,KAAK;EAAAC,EAAA;EACJ;;EAEA;;EAEF;EACA;EACA;;EAEA;EACA,MAAM,CAACC,UAAU,EAAEC,aAAa,CAAC,GAAGhB,QAAQ,CAACa,SAAS,CAACI,KAAK,CAAC;EAE3D,MAAMC,gBAAgB,GAAIC,CAAgC,IAAK;IAC7Dd,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAGc,CAAC,CAAC,CAAC,CAAC;;IAEfb,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAGa,CAAC,CAACC,aAAa,CAACH,KAAK,CAAC;IACrC;EACF,CAAC;EACD,MAAMI,kBAAkB,GAAIF,CAAkC,IAAK;IACjEZ,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAGY,CAAC,CAAC;IAEfX,OAAO;IAAI;IACTW,CAAC,CAACG,GAAG,KAAK,OAAO;IAAI;IACrBd,OAAO,CAAC,CAAC,CAAC,CAAC;EACf,CAAC;EAED,MAAMe,kBAAkB,GACtBtB,CAAC,CAACQ,KAAK,IAAIE,aAAa,GAAG,GAAG,GAAGA,aAAa,GAAG,EAAE,CAAC;EAEtD,MAAMa,mBAAmB,GACvBvB,CAAC,CAACwB,KAAK,IACNhB,KAAK,GAAG,GAAG,GAAGR,CAAC,CAACyB,UAAU,GAAG,GAAG,GAAGzB,CAAC,CAAC0B,UAAU,CAAC,IAChDjB,SAAS,GAAG,GAAG,GAAGA,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC;;EAEtC,oBACEP,OAAA;IAAKO,SAAS,EAAET,CAAC,CAAC2B,YAAa;IAAAC,QAAA,gBAC7B1B,OAAA;MAAMS,EAAE,EAAEA,EAAE,GAAGA,EAAE,GAAG,OAAO,GAAGkB,SAAU;MAACpB,SAAS,EAAEa,kBAAmB;MAAAM,QAAA,EACpEpB;IAAK;MAAAsB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACF,CAAC,eAEP/B,OAAA;MACES,EAAE,EAAEA,EAAG;MACPuB,IAAI,EAAE,MAAO;MACb9B,QAAQ,EAAEa,gBAAiB;MAC3BX,UAAU,EAAEc,kBAAmB;MAC/BX,SAAS,EAAEc,mBAAoB;MAC/BP,KAAK,EAAEF,UAAW;MAAA,GACdF;IAAS;MAAAkB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACd,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACC,CAAC;AAEV,CAAC;AAACpB,EAAA,CA7DIV,cAAiD;AAAAgC,EAAA,GAAjDhC,cAAiD;AA+DvD,eAAeA,cAAc;AAAC,IAAAgC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}